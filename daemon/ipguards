#!/usr/bin/python
import sys, os, pwd, time
import simplejson, anydbm
import socket, threading, logging
from SocketServer import UnixStreamServer, ThreadingMixIn, StreamRequestHandler

DBMFILE = '/tmp/ipguards.db'
SOCKFILE = '/tmp/ipguards.sock'
SOCKPWD= pwd.getpwnam('apache')

def parse_request(line):
	line = line.strip()
	try: cmd,data = line.split(' ', 1)
	except: cmd,data = line,''
	data = simplejson.loads(data)
	return cmd,data

def add_rule(ipaddr):
	socket.inet_aton(ipaddr) # validate the ipaddr
	del_rule(ipaddr) # delete first to avoid duplication
	cmdline = '/sbin/iptables -A ipguards_input -s %s -j ACCEPT' % ipaddr
	return os.system(cmdline)

def del_rule(ipaddr):
	socket.inet_aton(ipaddr) # validate the ipaddr
	cmdline = '/sbin/iptables -D ipguards_input -s %s -j ACCEPT' % ipaddr
	return os.system(cmdline)

def authenticate(username, password):
	if username == 'test' and password == 'config': return True
	return False

class IPGuardHandler(StreamRequestHandler):
	def handle_grant(self, req):
		if not authenticate(req['username'], req['password']):
			res = {'msg':'authentication failure'}
			self.wfile.write('ERROR %s\n' % simplejson.dumps(res))
			logging.info('returns: ERROR %s' % simplejson.dumps(res))
			return False

		res = {'ipaddr':req['ipaddr'], 'expire':long(time.time()) + req['ttl']}
		self.server.db['%s@%s' % (req['username'], req['ipaddr'])] = str(res['expire'])
		logging.info('db[%s@%s] <= %s' % (req['username'], req['ipaddr'], res['expire']))
		add_rule(req['ipaddr'])

		self.wfile.write('OK %s\n' % simplejson.dumps(res))
		logging.info('returns: OK %s' % simplejson.dumps(res))
		return True

	def handle(self):
		self.server.lock.acquire()
		try:
			try:
				cmd,req = parse_request(self.rfile.readline())
				logging.info('get request %s: %s' % (cmd, req))
				if cmd == 'GRANT':
					self.handle_grant(req)
				else:
					res = {'msg':'invalid command'}
					self.wfile.write('ERROR %s\n' % simplejson.dumps(res))
			except:
				logging.exception('general handle exception')
				self.wfile.write('ERROR\n')
		finally:
			self.wfile.flush()
			self.server.lock.release()

class IPGuardServer(ThreadingMixIn, UnixStreamServer):
	timeout = 60

	def __init__(self, server_address, RequestHandlerClass):
		self.lock = threading.Lock()
		self.db = anydbm.open(DBMFILE, 'c', 0600)
		UnixStreamServer.__init__(self, server_address, RequestHandlerClass)

	def handle_timeout(self):
		self.lock.acquire()
		try:
			logging.info('handle_timeout')
			now = long(time.time())
			for key in self.db.keys():
				if '@' in key:
					data = simplejson.loads(db[key])
					if data['expire'] - now <= 0:
						user,ipaddr = key.split('@', 1)
						logging.info('expire %s@%s' % (user, ipaddr))
						del_rule(ipaddr)
						del db[key]
		finally:
			self.lock.release()

if __name__ == '__main__':
	handler = logging.StreamHandler()
	formatter = logging.Formatter('%(asctime)s pid=%(process)d %(levelname)s %(message)s')
	handler.setFormatter(formatter)
	logger = logging.getLogger(None)
	logger.addHandler(handler)
	logger.setLevel(logging.DEBUG)

	# TODO: complain and exit, if ipguards_input chain doesn't exist
	try: os.unlink(SOCKFILE)
	except: pass

	try:
		server = IPGuardServer(SOCKFILE, IPGuardHandler)
		os.chown(SOCKFILE, SOCKPWD.pw_uid, SOCKPWD.pw_gid)
		os.chmod(SOCKFILE, 0600)
		server.serve_forever()
	finally:
		try: os.unlink(SOCKFILE)
		except: pass
