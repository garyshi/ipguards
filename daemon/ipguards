#!/usr/bin/python
import sys
import pwd
import time
import anydbm
import logging
import simplejson
import socket
import threading
from SocketServer import UnixStreamServer, ThreadingMixIn, StreamRequestHandler

DBMFILE = '/tmp/ipguards.db'
SOCKFILE = '/tmp/ipguards.sock'
SOCKPWD= pwd.getpwnam('apache')

def parse_request(line):
	line = line.strip()
	try: cmd,data = line.split(' ', 1)
	except: cmd,data = line,''
	data = simplejson.loads(data)
	return cmd,data

def add_rule(ipaddr):
	socket.inet_aton(ipaddr) # validate the ipaddr
	del_rule(ipaddr) # delete first to avoid duplication
	cmdline = '/sbin/iptables -A ipguards_input -s %s -j ACCEPT' % ipaddr
	return os.system(cmdline)

def del_rule(ipaddr):
	socket.inet_aton(ipaddr) # validate the ipaddr
	cmdline = '/sbin/iptables -D ipguards_input -s %s -j ACCEPT' % ipaddr
	return os.system(cmdline)

def authenticate(username, password):
	if username == 'test' and password == 'config': return True
	return False

class IPGuardHandler(StreamRequestHandler):
	def handle_grant(req):
		if not authenticate(req['username'], req['password']):
			res = {'msg':'authentication failure'}
			self.wfile.write('ERROR %s\n' % simplejson.dumps(res))
			return False

		res = {'ipaddr':req['ipaddr'], 'expire':long(time.time()) + req['ttl']}
		self.server.db['%s@%s' % (req['username'], req['ipaddr'])] = res['expire']
		add_rule(req['ipaddr'])

		self.wfile.write('OK %s\n' % simplejson.dumps(res))
		return True

	def handle(self):
		self.server.lock.acquire()
		try:
			cmd,req = parse_request(self.rfile.readline())
			if cmd == 'GRANT':
				self.handle_grant(req)
			else:
				res = {'msg':'invalid command'}
				self.wfile.write('ERROR %s\n' % simplejson.dumps(res))
		except:
			self.wfile.write('ERROR\n')
		finally:
			self.wfile.flush()
			self.server.lock.release()

class IPGuardServer(ThreadingMixIn, UnixStreamServer):
	timeout = 60

	def __init__(self, server_address, RequestHandlerClass):
		self.lock = threading.Lock()
		self.db = anydbm.open(DBMFILE, 'c', 0600)
		super(IPGuardServer, self).__init__(server_address, RequestHandlerClass)

	def handle_timeout(self):
		self.lock.acquire()
		try:
			logging.info('handle_timeout')
			now = long(time.time())
			for key in self.db.keys():
				if '@' in key:
					data = simplejson.loads(db[key])
					if data['expire'] - now <= 0:
						user,ipaddr = key.split('@', 1)
						logging.info('expire %s@%s' % (user, ipaddr))
						del_rule(ipaddr)
						del db[key]
		finally:
			self.lock.release()

if __name__ == '__main__':
	try:
		server = IPGuardServer(SOCKFILE, IPGuardHandler)
		os.chown(SOCKFILE, SOCKPWD.pw_uid, SOCKPWD.pw_gid)
		os.chmod(SOCKFILE, 0600)
		server.serve_forever()
	finally:
		try: os.unlink(SOCKFILE)
		except: pass
