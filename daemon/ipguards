#!/usr/bin/env python
import sys, os, pwd, time
import getopt, termios
# module sha is deprecated in new python, but it's hard to be compatible with
# hmac module with sha and hashlib and keep the same code...
import binascii, hmac, sha
import simplejson, anydbm
import socket, threading, logging
from SocketServer import UnixStreamServer, ThreadingMixIn, StreamRequestHandler

DBMFILE = '/tmp/ipguards.db'
SOCKFILE = '/tmp/ipguards.sock'
SOCKPWD= pwd.getpwnam('apache')

def parse_request(line):
	line = line.strip()
	try: cmd,data = line.split(' ', 1)
	except: cmd,data = line,''
	data = simplejson.loads(data)
	return cmd,data

def sec_input(prompt=''):
	s = None
	fd = sys.stdin.fileno()
	old = termios.tcgetattr(fd)
	new = termios.tcgetattr(fd)
	new[3] = new[3] & ~termios.ECHO
	try:
		termios.tcsetattr(fd, termios.TCSADRAIN, new)
		#flush_input(fd)
		s = raw_input(prompt)
	finally:
		termios.tcsetattr(fd, termios.TCSADRAIN, old)
	print
	return s

def add_rule(ipaddr):
	socket.inet_aton(ipaddr) # validate the ipaddr
	del_rule(ipaddr) # delete first to avoid duplication
	cmdline = '/sbin/iptables -A ipguards_input -s %s -j ACCEPT' % ipaddr
	return os.system(cmdline)

def del_rule(ipaddr):
	socket.inet_aton(ipaddr) # validate the ipaddr
	cmdline = '/sbin/iptables -D ipguards_input -s %s -j ACCEPT' % ipaddr
	return os.system(cmdline)

def authenticate(username, password):
	if username == 'test' and password == 'config': return True
	return False

class IPGuardHandler(StreamRequestHandler):
	def handle_grant(self, req):
		if not authenticate(req['username'], req['password']):
			res = {'msg':'authentication failure'}
			self.wfile.write('ERROR %s\n' % simplejson.dumps(res))
			logging.info('returns: ERROR %s' % simplejson.dumps(res))
			return False

		res = {'ipaddr':req['ipaddr'], 'expire':long(time.time()) + req['ttl']}
		self.server.db['%s@%s' % (req['username'], req['ipaddr'])] = str(res['expire'])
		logging.info('db[%s@%s] <= %s' % (req['username'], req['ipaddr'], res['expire']))
		add_rule(req['ipaddr'])

		self.wfile.write('OK %s\n' % simplejson.dumps(res))
		logging.info('returns: OK %s' % simplejson.dumps(res))
		return True

	def handle(self):
		self.server.lock.acquire()
		try:
			try:
				cmd,req = parse_request(self.rfile.readline())
				logging.info('get request %s: %s' % (cmd, req))
				if cmd == 'GRANT':
					self.handle_grant(req)
				else:
					res = {'msg':'invalid command'}
					self.wfile.write('ERROR %s\n' % simplejson.dumps(res))
			except:
				logging.exception('general handle exception')
				self.wfile.write('ERROR\n')
		finally:
			self.wfile.flush()
			self.server.lock.release()

class IPGuardServer(ThreadingMixIn, UnixStreamServer):
	timeout = 60

	def __init__(self, server_address, RequestHandlerClass):
		self.lock = threading.Lock()
		self.db = anydbm.open(DBMFILE, 'c', 0600)
		UnixStreamServer.__init__(self, server_address, RequestHandlerClass)

	def handle_timeout(self):
		self.lock.acquire()
		try:
			logging.info('handle_timeout')
			now = long(time.time())
			for key in self.db.keys():
				if '@' in key:
					data = simplejson.loads(db[key])
					if data['expire'] - now <= 0:
						user,ipaddr = key.split('@', 1)
						logging.info('expire %s@%s' % (user, ipaddr))
						del_rule(ipaddr)
						del db[key]
		finally:
			self.lock.release()

def daemon(db):
	# TODO: complain and exit, if ipguards_input chain doesn't exist
	try: os.unlink(SOCKFILE)
	except: pass

	try:
		server = IPGuardServer(SOCKFILE, IPGuardHandler)
		os.chown(SOCKFILE, SOCKPWD.pw_uid, SOCKPWD.pw_gid)
		os.chmod(SOCKFILE, 0600)
		server.serve_forever()
	finally:
		try: os.unlink(SOCKFILE)
		except: pass

class UserManager(object):
	def __init__(self, db):
		self.db = db

	def list(self):
		for key in self.db.iterkeys():
			if not key.startswith('user-'): continue
			data = simplejson.loads(self.db[key])
			print key[5:]

	def add(self, username, method, method_data):
		data = {'method':method}
		data.update(method_data)
		self.db['user-%s' % username] = simplejson.dumps(data)

	def modify(self, username):

	def delete(self, username):
		del self.db['user-%s' % username]

	def passwd(self, username):
		key = 'user-%s' % username
		if key not in self.db:
			print >>sys.stderr, 'Error: user not exist'
			return False
		data = simplejson.loads(self.db[key])
		if data['method'] != 'static':
			print >>sys.stderr, 'Error: authenticate method is not static'
			return False
		# TODO: ask password
		# TODO: confirm password
		# TODO: random salt, set times, update password
		data['times'] = 100
		data['hash'] = self.static_hash(data, password)

	def static_hash(self, data, password):
		h = password
		for i in xrange(max(data.get('times',1), 1):
			h = hmac.new(data['salt'], h, sha).digest()
		return binascii.b2a_hex(h)

	def authenticate(self, username, password):
		key = 'user-%s' % username
		if key not in self.db: return False
		data = simplejson.loads(self.db[key])
		if data['method'] == 'static':
			return static_hash(data, password) == data['hash']
		elif data['method'] == 'totp':
			return False # TODO
		return False

def userman(db, action, args):
	username = None
	method = 'static'
	method_data = {'step':30}
	optlist,args = getopt.getopt(args, 'm:k:s:p:')
	for opt,value in optlist:
		if opt == '-m': method = value
		elif opt == '-k': method_data['key'] = value
		elif opt == '-s': method_data['step'] = value
		elif opt == '-p': method_data['pin'] = value
	# "users" doesn't have a username arg
	if args: username = args[0]

	m = UserManager(db)
	if action == 'users':
		m.list()
	elif action == 'useradd':
		m.add(username, method, method_data)
	elif action == 'usermod':
		m.modify(username, method, method_data)
	elif action == 'userdel':
		m.delete(username)
	elif action == 'passwd':
		m.passwd(username)

if __name__ == '__main__':
	handler = logging.StreamHandler()
	formatter = logging.Formatter('%(asctime)s pid=%(process)d %(levelname)s %(message)s')
	handler.setFormatter(formatter)
	logger = logging.getLogger(None)
	logger.addHandler(handler)
	logger.setLevel(logging.DEBUG)

	if len(sys.argv) < 2:
		print 'Usage:'
		print '\tipguards daemon'
		print '\tipguards users [-v]'
		print '\tipguards useradd [-m static|totp] [-k <totp_hexkey>] [-s <totp_step>] [-p <totp_pin>] <username>'
		print '\tipguards usermod [-m static|totp] [-k <totp_hexkey>] [-s <totp_step>] [-p <totp_pin>] <username>'
		print '\tipguards userdel <username>'
		print '\tipguards passwd <username>'
		sys.exit(1)

	action = sys.argv[1]
	db = anydbm.open(DBMFILE, 'c', 0600)

	if action == 'daemon':
		daemon(db)
	elif action.startswith('user') or action == 'passwd':
		userman(db, action, argv[2:])
